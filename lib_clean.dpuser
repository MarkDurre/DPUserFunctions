//Cube cleaning functions - need lib_wcs
dpuserdir=getenv("DPUSER_DIR")
run dpuserdir+"/functions/lib_wcs.dpuser"

function limits, val, rnge, onaxis {
  v=val
  if (onaxis==1) {
    if (v<2) v=2
    if (v>=rnge) v=rnge-1
  } else {
    if (v<1) v=1
    if (v>rnge) v=rnge
  }
  limits=int(v)
}

function checklimits, cube, x1, x2, y1, y2, z1, z2, nx {
//Check the limits are within cube range
//Co-ordinates on interp axis have to be LESS than axis size
  
  n1=naxis1(cube)
  n2=naxis2(cube)
  n3=naxis3(cube)
  nx1=(nx==1)
  nx2=(nx==2)
  nx3=(nx==3)
  x1=limits(x1,n1, nx1)
  x2=limits(x2,n1, nx1)
  y1=limits(y1,n2, nx2)
  y2=limits(y2,n2, nx2)
  z1=limits(z1,n3, nx3)
  z2=limits(z2,n3, nx3)
  checklimits=[x1,x2,y1,y2,z1,z2]
}

function interp, data, x, x1, x2 {
   v=(x-x1)/(x2-x1)*(data[x2]-data[x1])+data[x1]
   interp=v
} 

function dpixapply2, x, dpl, boxsize {
//Alternative to dpixapply function
  n1=naxis1(x)
  n2=naxis2(x)
  y = x
  y[where(dpl==1)]=0
  for (i=1;i<=n1;i++) {
    for (j=1;j<=n2; j++) {
      if (dpl[i,j]>=1) {
        y[i,j] = median(y[max(1,i-boxsize):min(n1,i+boxsize),max(1,j-boxsize):min(n2,j+boxsize)],0)
      }
    }
  }
  dpixapply2=y
}

