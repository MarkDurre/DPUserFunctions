//Spectrum (1D) functions
//Requires lib_wcs, lib_general

function spectrum_wave_to_vel, inbuff, clambda {
//Change spectrum axis from wavelength to velocity, zero velocity at clambda
  ns=naxis(inbuff) //Last axis is wavelength
  wcs=get_WCS_data(inbuff, ns)
  cp=wcs[1]
  cv=wcs[2]
  cd=wcs[3]
  cp+=(clambda-cv)/cd
  cd*=299792.458/clambda
  cv=0.0
  wcs=[cp, cv, cd]
  outbuff=inbuff
  set_WCS_data outbuff, wcs, ns
  spectrum_wave_to_vel=outbuff
}
  

function spectrum_make_disp, val, delt, pix, n {
//Make a dispersion value vector
//Val : starting value
//Delt : increment bewteen elements
//Pix : starting pixel for val (usually 1)
//N : number of elements
  if (nparams()<1) {
   print "SPECTRUM_MAKE_DISP: val, delt, pix, n"
   s=0
  } else {
  s=[0:n-1]*delt+val-(pix-1)*delt
  setfitskey s, "CRVAL1", val
  setfitskey s, "CDELT1", delt
  setfitskey s, "CD1_1", delt
  setfitskey s, "CRPIX1", pix
  }
  spectrum_make_disp=s
}

function spectrum_make_disp_n, val1, val2, n {
  delt=(val2-val1)/(n-1)
  spectrum_make_disp_n = spectrum_make_disp(val1, delt, 1, n)
}

function spectrum_make_disp_data, inbuff, axis {
  if nparams()<2 axis=naxis(inbuff) //Assume spectral axis is last
  cc=get_WCS_data(inbuff, axis)
  nx=getfitskey(inbuff, "NAXIS"+axis)
  spectrum_make_disp_data=spectrum_make_disp(cc[2],cc[3],cc[1],nx)
}

function spectrum_wavenum_to_length, inbuff {
//Convert a vector of wave numbers to wavelength
  outbuff=1/inbuff
  temp=inbuff
  n=naxis1(inbuff)
//Assume wavenum is in cm^-1 => nm output
  for (i=1;i<=n;i++) temp[i]=outbuff[n-i+1]*1e7
  spectrum_wavenum_to_length=temp
}

function spectrum_mask, inbuff, mask, value, flag {
//Assume last axis is spectral
//Flag = 0, values are pixels
//Flag = 1, values are wavelength
  if (nelements(mask)<2) {
    outbuff=inbuff
  } else {
    aspec=naxis(inbuff)
    nx=getfitskey(inbuff,"NAXIS"+aspec)
    outbuff=inbuff
    nmask=nelements(mask)/2
    for (i=1;i<=nmask;i++) {
      p1=mask[i*2-1]
      p2=mask[i*2]
      if (flag==1) {
        p1=cvt_WCS_pixel_data(inbuff,p1,aspec)
        p2=cvt_WCS_pixel_data(inbuff,p2,aspec)
      }
    //    print p1+" "+p2
      if (p1>1)&&(p2<=nx) { //Must be in range
        if (aspec==1) {
          outbuff[p1:p2]=value
        } else {
          outbuff[*,*,p1:p2]=value
        }
      }
    }
  }
  spectrum_mask=outbuff
  free outbuff
}

function spectrum_mask_from_nan, inbuff {
//Get spectral mask from Nan/Inf values of input spectrum
  nans=cblank(inbuff/inbuff) //1D data of 0s (Nan/Inf) or 1s (Good data)
//Go through nans and make pairs
  n=nelements(inbuff)
  pcount=0
  ppixels=longarray(2)
  state=1 //State is whether inside or outside a range of nans
  for (i=1;i<=n;i++) {
    if ((nans[i]==0)&&(state==1)){ //Swapping from good to nans
      state=0
      pcount++
      p=pcount*2-1
      ppixels[p]=i
//      print state+","+i+","+p
    }
    if ((nans[i]==1)&&(state==0)){ //Swapping from nans to goods
      state=1
      p=pcount*2
      ppixels[p]=i-1
//      print state+","+i+","+p
      resize ppixels,nelements(ppixels)+2,1
    }
  }
  if (state==0) ppixels[nelements(ppixels)]=n
  spectrum_mask_from_nan=ppixels
}

function spectrum_interp_mask, inbuff, mask {
//Interpolate over nans in spectrum
  outbuff=inbuff
  nregions=nelements(mask)/2
  for (i=1;i<=nregions;i++) {
    p1=mask[i*2-1]
    p2=mask[i*2]
//    print i+","+p1+","+p2
    outbuff=spectrum_interp(outbuff,p1,p2)
  }
  spectrum_interp_mask=outbuff
}

function spectrum_cont_slope, spec, mask, flag, order {
//1D continuum slope from spectrum with mask
  sspec=spectrum_mask(spec, mask, 0/0, flag)
  if (nparams()<4) order=1
  o=order
  if (o<2) o=1
  p=polyfit(sspec,o)
  spectrum_cont_slope=p
}

function spectrum_deslope, spec, mask, flag, order {
//Remove and normailze spectrum with mask
  n1=naxis1(spec)
  s=spectrum_cont_slope(spec,mask, flag, order)
  o=order
  if (o<2) o=1
  l=poly([1:n1],s[*,1])
  spectrum_deslope=spec/l
}

function spectrum_slope_sub, spec, mask, flag, order {
//Remove and normailze spectrum with mask
  n1=naxis1(spec)
  s=spectrum_cont_slope(spec,mask, flag, order)
  o=order
  if (o<2) o=1
  l=poly([1:n1],s[*,1])
  spectrum_slope_sub=spec-l
}

function spectrum_polyfit, inbuff, order, mask, flag {
//Fit spectrum with poly order=order
//Mask out mask
  outbuff=inbuff
  if (nelements(mask)>1) {
    outbuff=spectrum_mask(outbuff, mask, 0/0, flag)
  }
  o=order
  if (o<2) o=1
  fit=polyfit(outbuff,o)
  n1=naxis1(inbuff)
  x=[1:n1]
  polyout=poly(x,fit[*,1])
  spec_polyfit=fits(n1,5)
  spec_polyfit[*,1]=outbuff //Masked spectrum
  spec_polyfit[*,2]=polyout //Polynomial fit
  spec_polyfit[*,3]=outbuff-polyout //Difference
  spec_polyfit[*,4]=inbuff-polyout //Continuum subtracted
  spec_polyfit[*,5]=inbuff/polyout //Continuum normalised
  copyheader spec_polyfit,inbuff
  spectrum_polyfit=spec_polyfit
}

function spectrum_symm_flip, inbuff, lambda, part {
//Split and flip especially for broad/narrow lines
  flip_pixel=cvt_WCS_pixel_data(inbuff,lambda,1)
  n1=naxis1(inbuff)
  outbuff=inbuff*0/0
  if (part==0) {
    outbuff[1:flip_pixel]=inbuff[1:flip_pixel]
    if ((flip_pixel*2)>n1) {
      l=n1-flip_pixel
    } else {
      l=flip_pixel-1
    }
    for (i=1;i<=l;i++) {
      outbuff[flip_pixel+i]=outbuff[flip_pixel-i]
    }
    if ((flip_pixel+l)<n1) outbuff[flip_pixel+l+1:n1]=outbuff[flip_pixel+l]
  }  else {
    outbuff[flip_pixel:n1]=inbuff[flip_pixel:n1]
    if ((flip_pixel*2)<n1) {
      l=flip_pixel-1
    } else {
      l=n1-flip_pixel
    }
    for (i=1;i<=l;i++) {
      outbuff[flip_pixel-i]=outbuff[flip_pixel+i]
    } 
  }   
  spectrum_symm_flip=outbuff
}

function spectrum_wave_to_lambda, inbuff, v1, v2, nv {
//Convert spectrum in wavenumber to wavelength
//Assume wavenumbers in cm^-1, output in nm
//If v1, v2 are defined (>0), interpolate over that range of wavelengths
//Otherwise use the wavelength range of input spectrum
  if nparams()<2 {
    v1=0
    v2=0
    nv=0
  }
  n=naxis1(inbuff)
  w1=cvt_pixel_WCS_data(inbuff,1,1)
  w2=cvt_pixel_WCS_data(inbuff,n,1)
  l1=1e7/w2
  l2=1e7/w1
  xold=1e7/spectrum_make_disp_n(w1,w2,n)
  flip xold,1
  yold=inbuff
  flip yold,1
  if (v1>0) { 
    xnew=spectrum_make_disp_n(v1,v2,nv)
    l1=v1
    l2=v2
    n=nv
  } else {
    xnew=spectrum_make_disp_n(l1,l2,n)
  }
  ynew=interpol(yold,xold,xnew)
  outbuff=inbuff
  resize outbuff,n,1
  cd=(l2-l1)/n
  outbuff[1:n]=ynew
  setfitskey outbuff,"CRPIX1",1
  setfitskey outbuff,"CRVAL1",l1
  setfitskey outbuff,"CDELT1",cd
  setfitskey outbuff,"CD1_1",cd
  spectrum_wave_to_lambda=outbuff
}

function spectrum_lin_to_log, inbuff {
//Convert spectrum linear to log wavelength by interpolation
  n=naxis1(inbuff)
  w1=cvt_pixel_WCS_data(inbuff,1,1)
  w2=cvt_pixel_WCS_data(inbuff,n,1)
  xold=log(spectrum_make_disp_n(w1,w2,n))
  xnew=spectrum_make_disp_n(log(w1),log(w2),n)
  yold=inbuff
  ynew=interpol(cblank(yold),xold,xnew)
  outbuff=ynew
  cd=(log(w2)-log(w1))/n
  setfitskey outbuff,"CRPIX1",1
  setfitskey outbuff,"CRVAL1",log(w1)
  setfitskey outbuff,"CDELT1",cd
  setfitskey outbuff,"CD1_1",cd
  setfitskey outbuff,"CTYPE1","WAVE-LOG"
  spectrum_lin_to_log=outbuff
}

function spectrum_make_gauss, inbuff, bi, bs, h, lc, w {
//Make gaussian from fit
//b1, bs are intercept and slope of base
//h, c, w are height centre and sigma of gaussian
//X-axis range taken from inbuff 
//  print "SPECTRUM_MAKE_GAUSS : ",h,lc,w
  sp=spectrum_make_disp_data(inbuff, 1)
  base=bi+bs*sp
  gs=h*exp(-4*ln(2)*(sp-lc)^2/w^2)+base
  w=get_WCS_data(inbuff,1)
  set_WCS_data gs,w,1 
  spectrum_make_gauss=gs
}

function spectrum_make_lorentz, inbuff, bi, bs, h, lc, w {
//Make gaussian from fit
//b1, bs are intercept and slope of base
//h, c, w are height centre and sigma of gaussian
//X-axis range taken from inbuff 
//  print "SPECTRUM_MAKE_GAUSS : ",h,lc,w
  sp=spectrum_make_disp_data(inbuff, 1)
  base=bi+bs*sp
//  gs=h*exp(-4*ln(2)*(sp-lc)^2/w^2)+base
  gs=w/((sp-lc)^2+(w/2)^2)/(2*pi())*h/(2/pi()/w)+base
  w=get_WCS_data(inbuff,1)
  set_WCS_data gs,w,1 
  spectrum_make_lorentz=gs
}

function spectrum_flux_ul, inbuff, lambda, width, deslope, ignore {
//Find upper limit for flux over range, 3-sigma on noise
//Assume spectrum is in last axis and has correct WCS
//deslope is oder of polynomial fit to slope, if zero, do not deslope
//ignore - value to ignore (e.g. 0 or Nan)
  if (nparams()<5) ignore=0/0
  if (nparams()<4) deslope=0
  laxis=naxis(inbuff)
  p1=cvt_WCS_pixel_data(inbuff, lambda-width/2, laxis)
  p2=cvt_WCS_pixel_data(inbuff, lambda+width/2, laxis)
  if (laxis==1) spec=inbuff[p1:p2]
  if (laxis==3) spec=inbuff[*,*,p1:p2]
  if (deslope>0) {
    s=spectrum_deslope(spec,[0],0,deslope)
    spec=avg(spec)*s
  }
  if (isnan(ignore)==1) {
    sigma=stddev(spec)
  } else {
    sigma=stddev(spec, ignore)
  }      
  spectrum_flux_ul=3*sigma
}

function spectrum_redisp_lin, inbuff, data, daxis, xmin,delt, npix, zero, norms,  prnt, fluxcons {
//Redisperse spectrum, zeroing outside of old spectral range 
  if (nparams()<1) {
    print "SPECTRUM_REDISP_LIN: inbuff, data, daxis, xmin,delt, npix, zero, norms,  prnt, fluxcons"
    print "inbuff           : spectrum to be redispersed"
    print "data             : data with dispersal solution (if =0 then use parameters for dispersion)"
    print "daxis            : spectral axis of data (last)"
    print "xmin, delt, npix : dispersion solution if data=0"
    print "zero             : if =1, then set redispersed spectra to zero where out of original range, rather than NaN (=0)"
    print "norms            : if =1, normalize dispersed spectra [0,1] (=0)"
    print "prnt             : if =1, print spectral range information (=0)"
    print "fluxcons         : if =1, spectrum is flux, rather than flux density, so conserve total (=0)"
    spectrum_redisp_lin=0
    break
  }
  if (nparams()<10) fluxcons=0
  if (nparams()<9) prnt=0
  if (nparams()<8) norms=0
  if (nparams()<7) zero=0
  if (nparams()<6) npix=1
  if (nparams()<5) delt=1
  if (nparams()<4) xmin=1
  if (nparams()<3) daxis=naxis(data)
  yold=inbuff
  xold=spectrum_make_disp_data(inbuff, 1)
  xstart=xold[1]
  xend=xold[naxis1(xold)]
  if (prnt>0) print "SPECTRUM_REDISP_LIN: Old spectral range - "+xstart+":"+xend
  if (nelements(data)==1) {
    xnew=spectrum_make_disp(xmin, delt, 1, npix)
  } else {
    xnew=spectrum_make_disp_data(data, daxis)
  }
  if (prnt>0) print "SPECTRUM_REDISP_LIN: New spectral range - "+xnew[1]+":"+xnew[naxis1(xnew)]
  wcsnew=get_WCS_values(xnew)
  ynew=interpol(yold, xold, xnew)
  set_WCS_data ynew, wcsnew, 1
//Set to zero outside of orig. wavelength range if required
  if (zero==1) {
    nnew=naxis1(ynew)
    p1=cvt_WCS_pixel_data(ynew, xstart, 1)
    p2=cvt_WCS_pixel_data(ynew, xend, 1)
    if (p1>1) {
      ynew[1:p1]=0
    }
    if (p2<nnew) {
      ynew[p2:nnew]=0
    }
    print "SPECTRUM_REDISP: Trimming pixels - ["+p1+":"+p2+"]"
  }
//Flux conserve
  if (fluxcons==1) ynew=total(inbuff)/total(ynew)*ynew
//Normalise if required
  if (norms==1) {
    ynew=norm(ynew)
  }
  spectrum_redisp_lin=ynew
}

function spectrum_from_xy, inbuff, col {
//re-disperse spectrum from 2D x and y bintable to wavelength range and same number of points
//Assume wavelength is in the first column (index [0]) and flux is in column 2 (index [1])
//"col" selects column for flux - default 1
//Get wavelength and flux vectors
  if nparams()<2 col=1
  w=inbuff[0]
  f=inbuff[col]
  nw=naxis1(w)
  xstart=w[1]
  xend=w[nw]
  wnew=spectrum_make_disp_n(xstart,xend,nw)
  ynew=interpol(f,w,wnew)
  wcs=get_WCS_data(wnew, 1)
  set_WCS_data ynew, wcs, 1
  spectrum_from_xy=ynew
}

function spectrum_from_dataxy, xdata, ydata, l1, l2, npix, xscl, yscl {
//re-disperse spectrum from 2D x and y bintable to wavelength range and same number of points
//Get wavelength and flux vectors
  if (nparams()<7) yscl=1
  if (nparams()<6) xscl=1
  w=xdata*xscl
  f=ydata*yscl
  wnew=spectrum_make_disp_n(l1, l2, npix)
  ynew=interpol(f,w,wnew)
  wcsnew=get_WCS_data(wnew, 1)
  set_WCS_data ynew, wcsnew, 1
  spectrum_from_dataxy=ynew
}
/*
data = import("/Users/mdurre/Programs/STARLIGHT/BasesDir/bc2003_hr_m22_chab_ssp_020.spec", 0, " ", "", 6, /number)
xdata=data[1,*]/10
ydata=data[2,*]
w1=1000
w2=2500
delt=0.5
*/

function spectrum_interp, inbuff, x1, x2 {
//Smooth over bad pixels
  x0=x1-1
  x3=x2+1
  outbuff=inbuff
  l=nelements(inbuff) //Check range
  if (x1<=1) {
    v0=inbuff[x3]
    x0=x1
  } else {
    v0=inbuff[x0]
  }
  if (x2>=l) {
    v2=inbuff[x0]
    x3=x2
  } else {
    v2=inbuff[x3]
  }
  for (i=x1;i<=x2;i++) {
    v=(i-x0)/(x3-x0)*(v2-v0)+v0
    outbuff[i]=v
  }
  spectrum_interp=outbuff
}

function spectrum_from_tablexy, inbuff, l1, l2, npix, xscl, yscl {
//Rediserse input spectrum, assuming wavelength is in first column
//l1, l2, npix is new wavelength range and number of pixels
    if (nparams()<6) yscl=1
    if (nparams()<5) xscl=1
    if (nparams()<4) npix=naxis2(inbuff)
    if (nparams()<3) l2=max(inbuff[1,*])
    if (nparams()<2) l1=min(inbuff[1,*])
    xold=inbuff[1,*]*xscl //rescale to match new dispersion (e.g. from micron to nm, xscl=1000)
    xnew=spectrum_make_disp_n (l1, l2, npix)
    nx=naxis2(inbuff)
    outbuff=inbuff[2,*]
    resize outbuff, npix, 1
    yold=cblank(clip(inbuff[2,*],0,-1))*yscl //rescale data
    ynew=interpol(yold,xold,xnew) //Interpolate flux
    ynew=cblank(clip(ynew,0,-1))
    outbuff[*]=ynew
    cdelt=(l2-l1)/(npix-1)
    setfitskey outbuff, "CRPIX1", 1
    setfitskey outbuff, "CRVAL1",l1
    setfitskey outbuff, "CDELT1", cdelt
    setfitskey outbuff,"CTYPE1","WAVE"
    setfitskey outbuff,"CD1_1",cdelt
    setfitskey outbuff,"MINWAVE",min(xold),"Minimum wavelength observed (nm)"
    setfitskey outbuff,"MAXWAVE",max(xold),"Maximum wavelength observed (nm)"
    spectrum_from_tablexy=outbuff
}

function st, inbuff {
  st=spectrum_from_tablexy(inbuff)
}

function spectrum_redisp, inbuff, l1, l2, npix, xscl, yscl {
//Rediserse input spectrum
//l1, l2, npix is new wavelength range and number of pixels
    if (nparams()<6) yscl=1
    if (nparams()<5) xscl=1
    xold=spectrum_make_disp_data(inbuff,1)
    xnew=spectrum_make_disp_n (l1, l2, npix)
    yold=cblank(clip(inbuff,0,-1))*yscl //rescale data
    ynew=interpol(yold,xold,xnew) //Interpolate flux
    outbuff=cblank(clip(ynew,0,-1))
    cdelt=(l2-l1)/(npix-1)
    copyheader outbuff,inbuff
    setfitskey outbuff, "CRPIX1", 1
    setfitskey outbuff, "CRVAL1",l1
    setfitskey outbuff, "CDELT1", cdelt
    setfitskey outbuff,"CTYPE1","WAVE"
    setfitskey outbuff,"CD1_1",cdelt
    setfitskey outbuff,"MINWAVE",min(xold),"Minimum wavelength observed (nm)"
    setfitskey outbuff,"MAXWAVE",max(xold),"Maximum wavelength observed (nm)"
    spectrum_redisp=outbuff
}

function spectrum_redisp_loglin, inbuff {
//Redisperse spectrum with log-linear wavelength e.g.SDSS
//Start wavelength in CRVAL1, log steps in CD1_1
  w=getfitskey(inbuff,"CRVAL1")
  s=hdr_get_fits_key(inbuff,"CD1_1")
  if (s=="") s=hdr_get_fits_key(inbuff,"CDELT1")
  n=naxis1(inbuff)
  lw1=w
  lw2=w+s*n
  speclog=spectrum_make_disp_n(lw1,lw2,n)
  xold=10^speclog
  xnew=spectrum_make_disp_n(10^lw1,10^lw2,n)
  yold=cblank(clip(inbuff,0,-1))
  outbuff=interpol(yold,xold,xnew)
  cdelt=(max(xnew)-min(xnew))/(n-1)
  copyheader outbuff,inbuff
  setfitskey outbuff, "CRPIX1", 1
  setfitskey outbuff, "CRVAL1",10^lw1
  setfitskey outbuff, "CDELT1", cdelt
  setfitskey outbuff,"CTYPE1","WAVE"
  setfitskey outbuff,"CD1_1",cdelt
  spectrum_redisp_loglin=outbuff
}

function spectrum_clean, inbuff, thresh {
//Clean spectrum using dpixcreate/apply
  if nparams()<2 thresh=median(inbuff)/2
  inb=cblank(inbuff)
  dead=dpixcreate(inb, median(inb)/2)
  clean=dpixapply(inb, dead, method=1)
  spectrum_clean=clean
}

function spectrum_der_snr, inbuff, cutoff{
/* DESCRIPTION This function computes the signal to noise ratio DER_SNR following the
               definition set forth by the Spectral Container Working Group of ST-ECF,
               MAST and CADC. */
  if nparams()<2 cutoff=0
  data=cblank(inbuff) //Remove Nans
  data[where(data<=cutoff)]=0 //Zero out below cutoff value
  data=data[where(data!=0)] //Remove zero values
  ldata=nelements(data)
  if ldata>4 {
    signal=median(data)
    noise = 0.6052697 * median(abs(2*data[3:ldata-1]-data[1:ldata-3]-data[5:ldata]))
    spectrum_der_snr=signal/noise
  } else {
    spectrum_der_snr=0
  }
}

function spectrum_sn, inbuff, window {
//Estimate spectrum S/N from itself - not 100% accurate but good for comparisons
//Window is smoothing and noise estimation window in pixels - default is 10% of spectrum length
  if nparams()<2 window=int(naxis1(inbuff)*0.1)
  n1=naxis1(inbuff)
  n2=naxis2(inbuff)
  signal=smooth(cblank(inbuff), window) //Estimate signal
  no1=inbuff-signal
  no2=no1*0
  for (i=int(window/2)+1;i<=naxis1(inbuff)-int(window/2)-1;i++) {
    no2[i]=stddev(no1[i-int(window/2):i+int(window/2)],0)
  }
  no2[where(inbuff==0)]=0/0
  outbuff=resize(inbuff,n1,3)*0
  outbuff[*,1]=signal
  outbuff[*,2]=no2
  outbuff[*,3]=signal/no2
  spectrum_sn=outbuff
}

function spectrum_sn_wl, inbuff, lambda, width {
//Estimate spectrum S/N from itself at a defined wavelength/window width
  if nparams()<3 {
    print "SPECTRUM_SN_WL: Must provide wavelength and width"
    spectrum_sn_wl=0
    break
  } 
  wl1=cvt_WCS_pixel_data(inbuff,lambda-width/2,1)
  wl2=cvt_WCS_pixel_data(inbuff,lambda+width/2,1)
  if (wl1<1)||(wl2>naxis1(inbuff)) {
    print "SPECTRUM_SN_WL: Window out of wavelength range"
    spectrum_sn_wl=0
  } else {
    signal=avg(inbuff[wl1:wl2])
    noise=stddev(inbuff[wl1:wl2])
    spectrum_sn_wl=[signal,noise,signal/noise]
  }
}

function spectrum_noise, spectrum, snr {
//Create noise to a spectrum using a Gaussian realisation of the SNR
  n=naxis1(spectrum)
  outbuff=spectrum
  for (i=1;i<=n;i++) {
    if (nelements(snr)==1) {
      outbuff[i]=randomg(spectrum[i]/snr)
    } else {
      outbuff[i]=randomg(spectrum[i]/snr[i])
    }
  }
  spectrum_noise=outbuff
}

function spectrum_apply_snr, spectrum, snr {
//Add noise to a spectrum using a Gaussian realisation of the SNR
  n=naxis1(spectrum)
  outbuff=spectrum
  for (i=1;i<=n;i++) {
    if (nelements(snr)==1) {
      outbuff[i]+=randomg(spectrum[i]/snr)
    } else {
      outbuff[i]+=randomg(spectrum[i]/snr[i])
    }
  }
  spectrum_apply_snr=outbuff
}

function spectrum_comb_sigma, inbuff, sigma, toler, omit {
//Spectrum combine with sigma clipping algorithm
//inbuff is a 2d image with each row a spectrum
//sigma is standard deviations allowed (default 3 sigma)
//toler is tolerance for convergence on clipping algorithm (default 0.1)
//omit is value to omit on averaging (if parameter not entered, don't omit any value)
  n1=naxis1(inbuff)
  n3=naxis2(inbuff)
  noomit=0
  if nparams()<4 {
    noomit=1
  }
  if nparams()<3 toler=0.1
  if nparams()<2 sigma=3
/*  print "Average with sigma clipping"
  print "Image dimensions : ["+n1+","+n2+"]"
  print "# of images : "+n3
  print "Sigma/Tolerance : "+sigma+"/"+toler
  print "Omit value : "+omit*/
  outbuff=inbuff[*,1]*0
  for (i=1;i<=n1;i++) {
//    print "SPECTRUM_COMB_SIGMA Row: "+i
    tol=1
    s=1
    while (tol==1)&&(s>0) {
      m=median(inbuff[i,*],omit)
      s=meddev(inbuff[i,*])
      for (k=1;k<=n3;k++) {
        if (isnan(inbuff[i,k])==0) {
          if (abs(inbuff[i,k]-m)>(sigma*s)) {
      /*              print "Reject : ["+i+","+j+","+k+"]"
            print "Value : "+inbuff[i,j,k]
            print "Median : "+m+" Std Dev : "+s*/
            inbuff[i,k]=0/0
          }
        }
      }
      sigold=s
      signew=meddev(inbuff[i,*])
      t=(sigold-signew)/signew
      if (t<toler) tol=0
    //        print "Coords: "+i+","+j+" tol :"+tol+" m: "+m+" s: "+s+" sigold: "+sigold+" signew: "+signew+" t: "+t
    }
    if (noomit==0) {
    outbuff=avg(inbuff,/y)
    } else {
    outbuff=avg(inbuff,/y,omit)
    }
  }
  spectrum_comb_sigma=outbuff
}

function spectrum_range, inbuff, w1, w2 {
  r=pixel_range(inbuff, w1, w2, 1)
  spectrum_range=inbuff[r[1]:r[2]]
}

function spectrum_abs_index, inbuff, ll1, ll2, bc1, bc2, rc1, rc2 {
//Get absorption spectral indexes for a particular line
//inbuff - input spectrum
//ll1, ll2, bc1, bc2, rc1, rc2 - line limits, blue and red continuum wavelength ranges
//Returns 2x1 matrix [index, sd_index]
  if (nparams()<7) {
    print "SPECTRUM_ABS_INDEX : Error - not enough parameters"
    print "SPECTRUM_ABS_INDEX : inbuff, ll1, ll2, bc1, bc2, rc1, rc2"
  }
//Average over the line, blue and red
  ll=spectrum_range(inbuff, ll1, ll2)
  bc=spectrum_range(inbuff, bc1, bc2)
  rc=spectrum_range(inbuff, rc1, rc2)
  all=avg(ll)
  abc=avg(bc)
  arc=avg(rc)
  blambda=(bc1+bc2)/2
  rlambda=(rc1+rc2)/2
  llambda=(ll1+ll2)/2
//Interpolate from midpoints of red and blue continuum to midpoint of line
  fcont=abc+(arc-abc)*(llambda-blambda)/(rlambda-blambda)
  fluxdens=avg(1-ll/fcont)
  lwidth=abs(ll2-ll1)
  ew=fluxdens*lwidth
  sdll=stddev(ll)
  sdbc=stddev(bc)
  sdrc=stddev(rc)
  sdcont=sqrt(sdbc^2+sdrc^2)
  ewsd=ew*sqrt((sdll/all)^2+(sdcont/fcont)^2)
  spectrum_abs_index=[ew,ewsd]
}
