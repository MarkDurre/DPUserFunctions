//Weighted Voronoi tesselation function
//Requires lib_wcs, lib_masking

function wvt_build_from_map_cube, inbuff, wvtmap, prnt {
//wvtmap generated by voronoi with /map switch.
//min value is 1 (add 1 to voronoi map, which starts at zero
//value=0 - ignore in build
    if (nparams()<3) prnt=0
    n1=naxis1(inbuff)
    n2=naxis2(inbuff)
    n3=naxis3(inbuff)
    nregions=int(max(wvtmap)+1)
    specarray=fits(n3,nregions) //Spectrum accumulation
    cntspecarray=longarray(nregions) //count accumulation
//Accumulate spectra through cube
    print "WVT_BUILD_FROM_MAP_CUBE: Accumulating : "+nregions
    for (i=1;i<=n1;i++){
      if (prnt>0) print "Column : "+i
      for (j=1;j<=n2;j++){
        n=int(wvtmap[i,j]+1)
        if (n>0) {
          spec=inbuff[i,j,*]
          cntspecarray[n]++
          specarray[*,n]=specarray[*,n]+spec
        }
      }
    }
//Average each spectrum
    for (n=1;n<=nregions;n++) { 
      specarray[*,n]=specarray[*,n]/cntspecarray[n]
      if (prnt>0)&&((n%100)==1) print "WVT_BUILD_FROM_MAP_CUBE: Spectrum : "+n
    }
//Rebuild spectra through cube
    outbuff=inbuff*0
    print "WVT_BUILD_FROM_MAP_CUBE: Rebuilding : "+nregions
    for (i=1;i<=n1;i++){
      if (prnt>0) print "WVT_BUILD_FROM_MAP_CUBE: Column : "+i
      for (j=1;j<=n2;j++){
        n=int(wvtmap[i,j]+1)
        if (n>0) {
          spec=specarray[*,n]
          outbuff[i,j,*]=spec
        }
      }
    }
    wvt_build_from_map_cube = outbuff
}

function wvt_build_from_map_image, inbuff, wvtmap {
//wvtmap generated by voronoi with /map switch.
//min value is 1 (add 1 to voronoi map, which starts at zero
//value=0 - ignore in build
    n1=naxis1(inbuff)
    n2=naxis2(inbuff)
    nregions=int(max(wvtmap)+1)
    specarray=fits(nregions) //Spectrum accumulation
    cntspecarray=longarray(nregions) //count accumulation
//Accumulate spectra through cube
    print "WVT_BUILD_FROM_MAP_IMAGE: Accumulating : "+nregions
    for (i=1;i<=n1;i++){
      for (j=1;j<=n2;j++){
        n=int(wvtmap[i,j]+1)
        if (n>0) {
          spec=inbuff[i,j]
          cntspecarray[n]++
          specarray[n]=specarray[n]+spec
        }
      }
    }
//Average each spectrum
    for (n=1;n<=nregions;n++) { 
      specarray[n]=specarray[n]/cntspecarray[n]
    }
//Rebuild spectra through cube
    outbuff=inbuff*0
    print "WVT_BUILD_FROM_MAP_IMAGE: Rebuilding : "+nregions
    for (i=1;i<=n1;i++){
      for (j=1;j<=n2;j++){
        n=int(wvtmap[i,j]+1)
        if (n>0) {
          spec=specarray[n]
          outbuff[i,j]=spec
        }
      }
    }
    wvt_build_from_map_image = outbuff
}

function wvt_cube, cube, sn_target {
//Weighted Voronoi tesselation for data cube
//First create signal and noise maps
    print "WVT_CUBE: Building signal map"
    inbuff=cblank(cube)
    n1=naxis1(inbuff)
    n2=naxis2(inbuff)
/*Functionality here*/
    sig_map=cubemedian(inbuff,0)
    sig_min=min(sig_map)
    sig_max=max(sig_map)
    xs=xmax(sig_map)
    ys=ymax(sig_map)
    noise_map=sig_map*0
//create mask for complete range
    mask=sig_map*0
    mask[where(sig_map>0)]=1
//Smooth subtract over 5 percent of spectrum
    smthcnt=int(naxis3(inbuff)*0.05)
    print "WVT_CUBE: Building noise map"
    for (i=1;i<=n1;i++){
//      print i
      for (j=1;j<=n2;j++){
        spec=inbuff[i,j,*]
        spec_smth=spec-smooth(spec,smthcnt)
        md=meddev(spec_smth)
        spec_smth[where(abs(spec_smth)>5*md)]=0
        noise_map[i,j]=stddev(spec_smth,0)
      }
    }
    ns_min=min(noise_map)
    ns_max=max(noise_map)
    bp_sn=sig_map[xs,ys]/noise_map[xs,ys]
//Remove bad S/N values - criterion > 10x brightest pixel S/N
    snmap=sig_map/noise_map
    sig_map[where(snmap>(10*bp_sn))]=0
    noise_map[where(snmap>(10*bp_sn))]=0
    print "WVT_CUBE: Signal range : "+sig_min+" - "+sig_max
    print "WVT_CUBE: Noise  range : "+ns_min+" - "+ns_max
    msn=max(sig_map/noise_map)
    print "WVT_CUBE: Max S/N : "+msn
    print "WVT_CUBE: Brightest pixel S/N : "+bp_sn+" @ ["+xs+","+ys+"]"
    print "WVT_CUBE: Making WVT map"
    noise_map=noise_map+(ns_max-ns_min)/100 //noise map musn't be zero
    vmap=voronoi(sig_map,noise_map,sig_map,sn_target,/map)+1
    vmap=vmap*mask
//
    print "WVT_CUBE: Rebuilding cube from  WVT map"
    vcube=wvt_build_from_map_cube(cube, vmap)
    setfitskey vcube, "WVT-SN", sn_target
    print "WVT_CUBE: Finished!"
    wvt_cube=vcube
}

function wvt_cube_mask, cube, l1, l2, mask, cutoff, sn1, sn2 {
/*
cube    = 3D IFU cube
l1,l2   = wavelength range to take S/N - should be quiet are of spectrum without emission lines
mask    = 2D, mask, where =1 use sn1, where =2 use sn2
        = 1D, create mask from median image, using cutoff value
cutoff  = cutoff value in percentage of maximum
sn1,sn2 = S/N values for inner and outer region. If sn2=0, ignore masking
output  = WVT on data cube
*/

//Create WVT maps 
//Result has signal, noise, WVT binned and WVT map 
  p1=cvt_WCS_pixel_data(cube, l1, 3)
  p2=cvt_WCS_pixel_data(cube, l2, 3)
//Trim input cube to region without spectral lines
  contcube=cube[*,*,p1:p2]
  wvtsignal=cblank(avg(contcube,/z))
//Remove continuum slope  
  contspec=total(contcube,/xy)
  pfit=polyfit(contspec,1) //Straight line fit to continuum
  nx=naxis1(contspec)
  contslope=norm(poly([1:nx],pfit[*,1]),/average)
  wvtnoise=cblank(stddev(contcube/contslope,/z))
  wvtbin1=voronoi(wvtsignal,wvtnoise, cube,sn1)
  if (naxis(mask)==1) mask=mask_from_image(norm(wvtsignal),cutoff/100,0)
  if (sn2>0) {
    wvtbin2=voronoi(wvtsignal,wvtnoise, cube,sn2)
    wvtbin=wvtbin1*mask+wvtbin2*(1-mask)
  } else {
    wvtbin=wvtbin1
  }
//Create output data
  wvt_cube_mask=wvtbin
}

function wvt_sn_mask, cube, l1, l2, mask, cutoff, sn1, sn2 {
//As above, but output is cube with signal, noise, S/N, mask, binning and map on the signal
//Create WVT maps 
//Result has signal, noise, WVT binned and WVT map 
  p1=cvt_WCS_pixel_data(cube, l1, 3)
  p2=cvt_WCS_pixel_data(cube, l2, 3)
//Trim input cube to region without spectral lines
  contcube=cube[*,*,p1:p2]
  wvtsignal=avg(contcube,/z)
//Remove continuum slope  
  contspec=total(contcube,/xy)
  pfit=polyfit(contspec,1) //Straight line fit to continuum
  nx=naxis1(contspec)
  contslope=norm(poly([1:nx],pfit[*,1]),/average)
  wvtnoise=stddev(contcube/contslope,/z)
  wvtbin1=voronoi(wvtsignal,wvtnoise, wvtsignal,sn1)
  wvtmap1=voronoi(wvtsignal,wvtnoise, wvtsignal,sn1,/map)
  if (naxis(mask)==1) mask=mask_from_image(norm(wvtsignal),cutoff/100,0)
  if (sn2>0) {
    wvtbin2=voronoi(wvtsignal,wvtnoise, wvtsignal,sn2)
    wvtmap2=voronoi(wvtsignal,wvtnoise, wvtsignal,sn2,/map)
    wvtmap1_max=max(wvtmap1*mask)
    wvtbinb1=wvtbin1*mask
    wvtbinb2=wvtbin2*(1-mask)
    wvtbin=wvtbinb1+wvtbinb2
    wvtmapm1=wvtmap1*mask
    wvtmapm2=(wvtmap2+wvtmap1_max+1)*(1-mask)
    wvtmap=wvtmapm1+wvtmapm2
  } else {
    wvtbin=wvtbin1
    wvtmap=wvtmap1
  } 
  cntmap=longarray(int(max(wvtmap))+1)
  for (i=1;i<=nelements(wvtmap);i++) {
    index=int(wvtmap[i]+1)
    cntmap[index]++
  }
  dens=norm(1/cntmap)
  wvtdens=wvtmap*0
  for (i=1;i<=nelements(wvtmap);i++) wvtdens[i]=dens[wvtmap[i]+1]
//Create output data
  outdata=cube[*,*,1:7]*0
  outdata[*,*,1]=wvtsignal
  outdata[*,*,2]=wvtnoise
  outdata[*,*,3]=wvtsignal/wvtnoise
  outdata[*,*,4]=mask
  outdata[*,*,5]=wvtbin
  outdata[*,*,6]=wvtmap
  outdata[*,*,7]=wvtdens
  setfitskey outdata, "CRPIX3", 1
  setfitskey outdata, "CRVAL3", 0.5
  setfitskey outdata, "CD3_3", 1
  setfitskey outdata, "CDELT3", 1
  setfitskey outdata, "WVTSN1", sn1
  setfitskey outdata, "WVTSN2", sn2
  wvt_sn_mask=outdata
}

function wvt_velmap, velmp, layer, sn {
//Do wvt on velmap based on layer, 1=continuum, 2=flux
  mm=velmp[*,*,layer]
  signal=clip(cblank(mm),0,-1)
  noise=velmp[*,*,layer+4]
//Accomodate NaN for noise by setting all to min
  minns=min(noise)
  maxns=max(noise)
  noise=clip(cblank(noise),minns,maxns)
  w=voronoi(signal,noise,velmp,sn)
  mask=mask_from_image_nan(mm)
  wvt_velmap=w*mask

}

function wvt_density, wvt_map {
//Build map density (i.e. inverse of region size) from WVT map
    n1=naxis1(wvt_map)
    n2=naxis2(wvt_map)
    n_regions=max(wvt_map)+1
    outbuff=wvt_map*0
    cnt_array=longarray(int(n_regions)) //count accumulation
    for (i=1;i<=n1;i++){
      for (j=1;j<=n2;j++){
        n=int(wvt_map[i,j])+1
        cnt_array[n]++
      }
    }
    wvt_density=1/cnt_array
    for (i=1;i<=n1;i++){
      for (j=1;j<=n2;j++){
        n=int(wvt_map[i,j])+1
        outbuff[i,j]=wvt_density[n]
      }
    }
    wvt_density=outbuff
}

function wvt_cube_to_specarray, inbuff, wvtmap, nrm, prnt {
//wvtmap generated by voronoi with /map switch.
//min value is 1 (add 1 to voronoi map, which starts at zero
//value=0 - ignore in build
    n1=naxis1(inbuff)
    n2=naxis2(inbuff)
    n3=naxis3(inbuff)
    wavewcs=get_WCS_data(inbuff,3)
    nregions=int(max(wvtmap)+1)-int(max(min(wvtmap),0))
    specarray=fits(n3+1,nregions) //Spectrum accumulation
    cntspecarray=longarray(nregions) //count accumulation
//Accumulate spectra through cube
    print "WVT_CUBE_TO_SPECARRAY: Accumulating : "+nregions
    for (i=1;i<=n1;i++){
      if (prnt>0) print "WVT_CUBE_TO_SPECARRAY: Column : "+i
      for (j=1;j<=n2;j++){
        n=int(wvtmap[i,j]+1)
        if (n>0) {
          spec=inbuff[i,j,*]
          cntspecarray[n]++
          specarray[1,n]=n
          specarray[2:n3,n]=specarray[2:n3,n]+spec
        }
      }
    }
//Average each spectrum
    for (n=1;n<=nregions;n++) { 
      specarray[2:n3,n]=specarray[2:n3,n]/cntspecarray[n]
      if (prnt>0)&&((n%100)==1) print "WVT_CUBE_TO_SPECARRAY: Spectrum : "+n
    }
    wcs_y=[1.,1.,1.]
    set_WCS_data specarray, wavewcs, 1
    setfitskey specarray, "CRPIX1", 2
    set_WCS_data specarray, wcs_y, 2
    if (nrm>0) {
      for (i=1;i<=nregions;i++) {
        specarray[2:n3,i]/=median(specarray[2:n3,i])
        if (specarray[1,i]==0) specarray[*,i]=0/0
      }
    }
    print "WVT_CUBE_TO_SPECARRAY: Finished!"
    wvt_cube_to_specarray=specarray
}

function wvt_specarray_to_cube, inbuff, wvtmap {
//wvtmap generated by voronoi with /map switch.
//min value is 1 (add 1 to voronoi map, which starts at zero
//value=0 - ignore in build
    n1=naxis1(wvtmap)
    n2=naxis2(wvtmap)
    n3=naxis1(inbuff)
    ma=max(wvtmap)+1
    nspec=naxis2(inbuff)
    data=floatarray(int(ma),int(n3-1))*0/0
    for (i=1;i<=nspec;i++) data[int(inbuff[1,i]),1:n3-1]=inbuff[2:n3,i]
    cube=fits(n1,n2,n3-1)*0/0
    for (i=1;i<=n1;i++) {
      for (j=1;j<=n2;j++) {
        ns=wvtmap[i,j]
        if (ns>0) cube[i,j,*]=data[int(ns),*]
      }
    }
    wvt_specarray_to_cube=cube
}


